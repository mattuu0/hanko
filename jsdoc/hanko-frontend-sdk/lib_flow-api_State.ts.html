

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> lib/flow-api/State.ts</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="Action_Action.html">Action</a></li><li><a href="Hanko.html">Hanko</a></li><li><a href="SessionState_SessionState.html">SessionState</a></li><li><a href="State_State.html">State</a></li><li><a href="WebauthnManager.html">WebauthnManager</a></li></ul><h3>Interfaces</h3><ul><li><a href="HankoOptions.html">HankoOptions</a></li></ul></div><div class="category"><h2>SDK</h2><h3>Classes / FlowAPI</h3><ul><li><a href="Action.html">Action</a></li><li><a href="State.html">State</a></li></ul><h3>Classes / Internal</h3><ul><li><a href="Client.html">Client</a></li><li><a href="Cookie.html">Cookie</a></li><li><a href="Dispatcher.html">Dispatcher</a></li><li><a href="Headers.html">Headers</a></li><li><a href="HttpClient.html">HttpClient</a></li><li><a href="Relay.html">Relay</a></li><li><a href="Response.html">Response</a></li><li><a href="Scheduler.html">Scheduler</a></li><li><a href="SessionChannel.html">SessionChannel</a></li><li><a href="SessionState.html">SessionState</a></li><li><a href="SessionStorage.html">SessionStorage</a></li><li><a href="Throttle.html">Throttle</a></li><li><a href="WindowActivityManager.html">WindowActivityManager</a></li></ul><h3>Classes / Errors</h3><ul><li><a href="ConflictError.html">ConflictError</a></li><li><a href="EmailAddressAlreadyExistsError.html">EmailAddressAlreadyExistsError</a></li><li><a href="ForbiddenError.html">ForbiddenError</a></li><li><a href="HankoError.html">HankoError</a></li><li><a href="InvalidPasscodeError.html">InvalidPasscodeError</a></li><li><a href="InvalidPasswordError.html">InvalidPasswordError</a></li><li><a href="InvalidWebauthnCredentialError.html">InvalidWebauthnCredentialError</a></li><li><a href="MaxNumOfEmailAddressesReachedError.html">MaxNumOfEmailAddressesReachedError</a></li><li><a href="MaxNumOfPasscodeAttemptsReachedError.html">MaxNumOfPasscodeAttemptsReachedError</a></li><li><a href="NotFoundError.html">NotFoundError</a></li><li><a href="PasscodeExpiredError.html">PasscodeExpiredError</a></li><li><a href="RequestTimeoutError.html">RequestTimeoutError</a></li><li><a href="TechnicalError.html">TechnicalError</a></li><li><a href="ThirdPartyError.html">ThirdPartyError</a></li><li><a href="TooManyRequestsError.html">TooManyRequestsError</a></li><li><a href="UnauthorizedError.html">UnauthorizedError</a></li><li><a href="UserVerificationError.html">UserVerificationError</a></li><li><a href="WebauthnRequestCancelledError.html">WebauthnRequestCancelledError</a></li></ul><h3>Classes / Events</h3><ul><li><a href="Listener.html">Listener</a></li></ul><h3>Classes / Clients</h3><ul><li><a href="SessionClient.html">SessionClient</a></li><li><a href="UserClient.html">UserClient</a></li></ul><h3>Classes / Utilities</h3><ul><li><a href="WebauthnSupport.html">WebauthnSupport</a></li></ul><h3>Interfaces / Internal</h3><ul><li><a href="BroadcastMessage.html">BroadcastMessage</a></li><li><a href="CookieOptions.html">CookieOptions</a></li><li><a href="HttpClientOptions.html">HttpClientOptions</a></li><li><a href="SessionStorageOptions.html">SessionStorageOptions</a></li><li><a href="ThrottleOptions.html">ThrottleOptions</a></li></ul><h3>Interfaces / DTO</h3><ul><li><a href="Email.html">Email</a></li><li><a href="Emails.html">Emails</a></li><li><a href="Identity.html">Identity</a></li><li><a href="SessionCheckResponse.html">SessionCheckResponse</a></li></ul><h3>Interfaces / Events</h3><ul><li><a href="SessionDetail.html">SessionDetail</a></li></ul><h3><a href="global.html">Global</a></h3></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>lib/flow-api/State.ts</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { Hanko } from "../../Hanko";
import { Actions, Payloads, StateName } from "./types/state";
import { Input } from "./types/input";
import { FlowError } from "./types/flowError";
import { Action as ActionType } from "./types/action";
import { AnyState, FlowName, FlowResponse } from "./types/flow";
import { autoSteps } from "./auto-steps";
import { passkeyAutofillActivationHandlers } from "./passkey-autofill-activation";

export type AutoSteppedStates = keyof typeof autoSteps;

export type PasskeyAutofillStates =
  keyof typeof passkeyAutofillActivationHandlers;

export type AutoStepExclusion = AutoSteppedStates[] | "all";

export type ActionMap&lt;TState extends StateName> = {
  [K in keyof Actions[TState]]: Action&lt;
    Actions[TState][K] extends ActionType&lt;infer TInputs> ? TInputs : never
  >;
};

export type ActionInfo = {
  name: string;
  relatedStateName: StateName;
};

export interface StateInitConfig {
  dispatchAfterStateChangeEvent?: boolean;
  excludeAutoSteps?: AutoStepExclusion;
  previousAction?: ActionInfo;
  isCached?: boolean;
  cacheKey?: string;
}

export type StateCreateConfig = Pick&lt;
  StateInitConfig,
  "dispatchAfterStateChangeEvent" | "excludeAutoSteps" | "cacheKey"
> &amp; {
  loadFromCache?: boolean;
};

export type ActionRunConfig = Pick&lt;
  StateInitConfig,
  "dispatchAfterStateChangeEvent"
>;

type SerializedState = FlowResponse&lt;any> &amp; {
  flow_name: FlowName;
  previous_action?: ActionInfo;
  is_cached?: boolean;
};

type ExtractInputValues&lt;TInputs> = {
  [K in keyof TInputs]: TInputs[K] extends Input&lt;infer TValue> ? TValue : never;
};

/**
 * Represents a state in a flow with associated actions and properties.
 * @template TState - The specific state name type.
 * @constructor
 * @param {Hanko} hanko - The Hanko instance for API interactions.
 * @param {FlowName} flowName - The name of the flow this state belongs to.
 * @param {FlowResponse&lt;TState>} response - The flow response containing state data.
 * @param {StateInitConfig} [options={}] - Configuration options for state initialization.
 * @category SDK
 * @subcategory FlowAPI
 */
export class State&lt;TState extends StateName = StateName> {
  public readonly name: TState;
  public readonly flowName: FlowName;
  public error?: FlowError;
  public readonly payload?: Payloads[TState];
  public readonly actions: ActionMap&lt;TState>;
  public readonly csrfToken: string;
  public readonly status: number;
  public readonly previousAction?: ActionInfo;
  public readonly isCached: boolean;
  public readonly cacheKey: string;
  public readonly hanko: Hanko;
  public invokedAction?: ActionInfo;
  public readonly excludeAutoSteps: AutoStepExclusion;

  public readonly autoStep?: TState extends AutoSteppedStates
    ? () => Promise&lt;AnyState>
    : never;
  public readonly passkeyAutofillActivation: TState extends PasskeyAutofillStates
    ? () => Promise&lt;void>
    : never;

  /**
   * Constructs a new State instance.
   * @param {Hanko} hanko - The Hanko instance for API interactions.
   * @param {FlowName} flowName - The name of the flow this state belongs to.
   * @param {FlowResponse&lt;TState>} response - The flow response containing state data.
   * @param {StateInitConfig} [options={}] - Configuration options for state initialization.
   */
  constructor(
    hanko: Hanko,
    flowName: FlowName,
    response: FlowResponse&lt;TState>,
    options: StateInitConfig = {},
  ) {
    this.flowName = flowName;
    this.name = response.name;
    this.error = response.error;
    this.payload = response.payload;
    this.csrfToken = response.csrf_token;
    this.status = response.status;
    this.hanko = hanko;
    this.actions = this.buildActionMap(response.actions);

    if (this.name in autoSteps) {
      const handler = autoSteps[this.name as AutoSteppedStates];
      (this.autoStep as () => Promise&lt;AnyState>) = () => handler(this as any);
    }

    if (this.name in passkeyAutofillActivationHandlers) {
      const handler =
        passkeyAutofillActivationHandlers[this.name as PasskeyAutofillStates];
      (this.passkeyAutofillActivation as () => Promise&lt;void>) = () =>
        handler(this as any);
    }

    const {
      dispatchAfterStateChangeEvent = true,
      excludeAutoSteps = null,
      previousAction = null,
      isCached = false,
      cacheKey = "hanko-flow-state",
    } = options;

    this.excludeAutoSteps = excludeAutoSteps;
    this.previousAction = previousAction;
    this.isCached = isCached;
    this.cacheKey = cacheKey;

    if (dispatchAfterStateChangeEvent) {
      this.dispatchAfterStateChangeEvent();
    }
  }

  /**
   * Builds the action map for this state, wrapping it in a Proxy to handle undefined actions.
   * @param {Actions} actions - The actions available in this state.
   * @returns {ActionMap&lt;TState>} The action map for the state.
   * @private
   */
  private buildActionMap(actions: Actions[TState]): ActionMap&lt;TState> {
    const actionMap: Partial&lt;ActionMap&lt;TState>> = {};

    Object.keys(actions).forEach((actionName) => {
      const key = actionName as keyof Actions[TState];
      const action = actions[key] as ActionType&lt;any>;

      actionMap[key] = new Action(action, this);
    });

    // Return a Proxy that handles missing keys
    return new Proxy(actionMap as ActionMap&lt;TState>, {
      get: (target: ActionMap&lt;TState>, prop: string | symbol): Action&lt;any> => {
        if (prop in target) {
          return target[prop as keyof ActionMap&lt;TState>];
        }

        const actionName = typeof prop === "string" ? prop : prop.toString();

        return Action.createDisabled(actionName, this);
      },
    });
  }

  /**
   * Dispatches an event after the state has changed.
   */
  public dispatchAfterStateChangeEvent() {
    this.hanko.relay.dispatchAfterStateChangeEvent({
      state: this as AnyState,
    });
  }

  /**
   * Serializes the current state into a storable format.
   * @returns {SerializedState} The serialized state object.
   */
  public serialize(): SerializedState {
    return {
      flow_name: this.flowName,
      name: this.name,
      error: this.error,
      payload: this.payload,
      csrf_token: this.csrfToken,
      status: this.status,
      previous_action: this.previousAction,
      actions: Object.fromEntries(
        (Object.entries(this.actions) as [string, Action&lt;any>][]).map(
          ([name, action]) => [
            name,
            {
              action: action.name,
              href: action.href,
              inputs: action.inputs,
              description: null,
            },
          ],
        ),
      ),
    };
  }

  /**
   * Saves the current state to localStorage.
   * @returns {void}
   */
  public saveToLocalStorage(): void {
    localStorage.setItem(
      this.cacheKey,
      JSON.stringify({ ...this.serialize(), is_cached: true }),
    );
  }

  /**
   * Removes the current state from localStorage.
   * @returns {void}
   */
  public removeFromLocalStorage(): void {
    localStorage.removeItem(this.cacheKey);
  }

  /**
   * Initializes a flow state, processing auto-steps if applicable.
   * @param {Hanko} hanko - The Hanko instance for API interactions.
   * @param {FlowName} flowName - The name of the flow.
   * @param {FlowResponse&lt;any>} response - The initial flow response.
   * @param {StateInitConfig} [options={}] - Configuration options.
   * @param {boolean} [options.dispatchAfterStateChangeEvent=true] - Whether to dispatch an event after state change.
   * @param {AutoStepExclusion} [options.excludeAutoSteps=null] - States to exclude from auto-step processing, or "all".
   * @param {ActionInfo} [options.previousAction=null] - Information about the previous action.
   * @param {boolean} [options.isCached=false] - Whether the state is loaded from cache.
   * @param {string} [options.cacheKey="hanko-flow-state"] - Key for localStorage caching.
   * @returns {Promise&lt;AnyState>} A promise resolving to the initialized state.
   */
  public static async initializeFlowState(
    hanko: Hanko,
    flowName: FlowName,
    response: FlowResponse&lt;any>,
    options: StateInitConfig = {},
  ): Promise&lt;AnyState> {
    let state = new State(hanko, flowName, response, options);

    if (state.excludeAutoSteps != "all") {
      while (
        state &amp;&amp;
        state.autoStep &amp;&amp;
        !state.excludeAutoSteps?.includes(state.name)
      ) {
        const nextState = await state.autoStep();
        if (nextState.name != state.name) {
          state = nextState;
        } else {
          return nextState;
        }
      }
    }

    return state;
  }

  /**
   * Retrieves and parses state data from localStorage.
   * @param {string} cacheKey - The key used to store the state in localStorage.
   * @returns {SerializedState | undefined} The parsed serialized state, or undefined if not found or invalid.
   */
  public static readFromLocalStorage(
    cacheKey: string,
  ): SerializedState | undefined {
    const raw = localStorage.getItem(cacheKey);
    if (raw) {
      try {
        return JSON.parse(raw) as SerializedState;
      } catch {
        return undefined;
      }
    }
  }

  /**
   * Creates a new state instance, using cached or fetched data.
   * @param {Hanko} hanko - The Hanko instance for API interactions.
   * @param {FlowName} flowName - The name of the flow.
   * @param {StateCreateConfig} [config={}] - Configuration options.
   * @param {boolean} [config.dispatchAfterStateChangeEvent=true] - Whether to dispatch an event after state change.
   * @param {AutoStepExclusion} [config.excludeAutoSteps=null] - States to exclude from auto-step processing, or "all".
   * @param {string} [config.cacheKey="hanko-flow-state"] - Key for localStorage caching.
   * @param {boolean} [config.loadFromCache=true] - Whether to attempt loading from cache.
   * @returns {Promise&lt;AnyState>} A promise resolving to the created state.
   */
  public static async create(
    hanko: Hanko,
    flowName: FlowName,
    config: StateCreateConfig = {},
  ): Promise&lt;AnyState> {
    const { cacheKey = "hanko-flow-state", loadFromCache = true } = config;
    if (loadFromCache) {
      const cachedState = State.readFromLocalStorage(cacheKey);
      if (cachedState) {
        return State.deserialize(hanko, cachedState, {
          ...config,
          cacheKey,
        });
      }
    }

    const newState = await State.fetchState(hanko, `/${flowName}`);
    return State.initializeFlowState(hanko, flowName, newState, {
      ...config,
      cacheKey,
    });
  }

  /**
   * Deserializes a state from a serialized state object.
   * @param {Hanko} hanko - The Hanko instance for API interactions.
   * @param {SerializedState} serializedState - The serialized state data.
   * @param {StateCreateConfig} [config={}] - Configuration options.
   * @param {boolean} [config.dispatchAfterStateChangeEvent=true] - Whether to dispatch an event after state change.
   * @param {AutoStepExclusion} [config.excludeAutoSteps=null] - States to exclude from auto-step processing, or "all".
   * @param {string} [config.cacheKey="hanko-flow-state"] - Key for localStorage caching.
   * @param {boolean} [config.loadFromCache=true] - Whether to attempt loading from cache.
   * @returns {Promise&lt;AnyState>} A promise resolving to the deserialized state.
   */
  public static async deserialize(
    hanko: Hanko,
    serializedState: SerializedState,
    config: StateCreateConfig = {},
  ): Promise&lt;AnyState> {
    return State.initializeFlowState(
      hanko,
      serializedState.flow_name,
      serializedState,
      {
        ...config,
        previousAction: serializedState.previous_action,
        isCached: serializedState.is_cached,
      },
    );
  }

  /**
   * Fetches state data from the server.
   * @param {Hanko} hanko - The Hanko instance for API interactions.
   * @param {string} href - The endpoint to fetch from.
   * @param {any} [body] - Optional request body.
   * @returns {Promise&lt;FlowResponse&lt;any>>} A promise resolving to the flow response.
   */
  static async fetchState(
    hanko: Hanko,
    href: string,
    body?: any,
  ): Promise&lt;FlowResponse&lt;any>> {
    try {
      const response = await hanko.client.post(href, body);
      return response.json();
    } catch (error) {
      return State.createErrorResponse(error);
    }
  }

  /**
   * Creates an error flow response.
   * @param {FlowError} error - The error to include in the response.
   * @returns {FlowResponse&lt;"error">} A flow response with error details.
   * @private
   */
  private static createErrorResponse(error: FlowError): FlowResponse&lt;"error"> {
    return {
      actions: null,
      csrf_token: "",
      name: "error",
      payload: null,
      status: 0,
      error,
    };
  }
}

/**
 * Represents an actionable operation within a state.
 * @template TInputs - The type of inputs required for the action.
 * @param {ActionType&lt;TInputs>} action - The action type definition.
 * @param {State} parentState - The state this action belongs to.
 * @param {boolean} [enabled=true] - Whether the action is enabled.
 * @category SDK
 * @subcategory FlowAPI
 */
export class Action&lt;TInputs> {
  public readonly enabled: boolean;
  public readonly href: string;
  public readonly name: string;
  public readonly inputs: TInputs;
  private readonly parentState: State;

  /**
   * Constructs a new Action instance.
   * @param {ActionType&lt;TInputs>} action - The action type definition.
   * @param {State} parentState - The state this action belongs to.
   * @param {boolean} [enabled=true] - Whether the action is enabled.
   */
  constructor(
    action: ActionType&lt;TInputs>,
    parentState: State,
    enabled: boolean = true,
  ) {
    this.enabled = enabled;
    this.href = action.href;
    this.name = action.action;
    this.inputs = action.inputs;
    this.parentState = parentState;
  }

  /**
   * Creates a disabled action instance.
   * @template TInputs - The type of inputs (inferred as empty).
   * @param {string} name - The name of the action.
   * @param {State} parentState - The state this action belongs to.
   * @returns {Action&lt;TInputs>} A disabled action instance.
   */
  static createDisabled&lt;TInputs>(
    name: string,
    parentState: State,
  ): Action&lt;TInputs> {
    return new Action(
      {
        action: name,
        href: "", // No valid href since it’s disabled
        inputs: {} as TInputs,
        description: "Disabled action",
      },
      parentState,
      false,
    );
  }

  /**
   * Executes the action, transitioning to a new state.
   * @param {ExtractInputValues&lt;TInputs>} [inputValues=null] - Values for the action's inputs.
   * @param {ActionRunConfig} [config={}] - Configuration options.
   * @param {boolean} [config.dispatchAfterStateChangeEvent=true] - Whether to dispatch an event after state change.
   * @returns {Promise&lt;AnyState>} A promise resolving to the next state.
   * @throws {FlowError} If the action is disabled or already invoked.
   */
  async run(
    inputValues: ExtractInputValues&lt;TInputs> = null,
    config: ActionRunConfig = {},
  ): Promise&lt;AnyState> {
    const {
      name,
      hanko,
      flowName,
      csrfToken,
      invokedAction,
      excludeAutoSteps,
      cacheKey,
    } = this.parentState;
    const { dispatchAfterStateChangeEvent = true } = config;

    if (!this.enabled) {
      throw new Error(
        `Action '${this.name}' is not enabled in state '${name}'`,
      );
    }

    if (invokedAction) {
      throw new Error(
        `An action '${invokedAction.name}' has already been invoked on state '${invokedAction.relatedStateName}'. No further actions can be run.`,
      );
    }

    this.parentState.invokedAction = {
      name: this.name,
      relatedStateName: name,
    };

    hanko.relay.dispatchBeforeStateChangeEvent({
      state: this.parentState as AnyState,
    });

    // Extract default values from this.inputs
    const defaultValues = Object.keys(this.inputs).reduce(
      (acc, key) => {
        const input = (this.inputs as any)[key] as Input&lt;any>;
        if (input.value !== undefined) {
          acc[key] = input.value;
        }
        return acc;
      },
      {} as Record&lt;string, any>,
    );

    // Merge defaults with user-provided inputs
    const mergedInputData = {
      ...defaultValues,
      ...inputValues,
    };

    const requestBody = {
      input_data: mergedInputData,
      csrf_token: csrfToken,
    };

    const response = await State.fetchState(hanko, this.href, requestBody);

    this.parentState.removeFromLocalStorage();

    return State.initializeFlowState(hanko, flowName, response, {
      dispatchAfterStateChangeEvent,
      excludeAutoSteps,
      previousAction: invokedAction,
      cacheKey,
    });
  }
}
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>


</body>
</html>
